## 基本概念

> 函数是一个命名了的代码块，我们通过调用函数执行相应的代码
> 函数定义的构成：返回类型，函数名，形参列表，函数体



### 函数调用

通过调用运算符即一对圆括号来执行函数，调用运算符作用于一个表达式，该表达式是**函数或指向函数的指针**，二者构成了调用表达式；调用表达式的类型就是函数的返回类型

函数的调用完成两项工作

	1. 一是初始化函数对应的形参
	2. 二是将控制权转移给被调用函数。此时，主调函数(calling function)的执行暂时被中断，被调函数(called function)开始执行


return语句：返回return语句中的值，将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。









### 函数返回类型

函数的返回类型**不能是**数组类型或函数类型（但可以是指向数组的指针和指向函数的指针）。





在C++语言中，名字有作用域，对象有生命周期。
名字的**作用域**是程序文本的一部分，名字在其中可见。
对象的**生命周期**是程序执行过程中该对象存在的一段时间

#### 局部对象

形参和函数体内部定义的变量统称为**局部变量**

局部变量对函数而言是“局部”的，仅在函数作用域内可见。
局部变量会**隐藏**在外层作用域中同名的其他所有声明（函数的默认实参不受此影响，如何理解？）



#### 生命周期

变量的生命周期与是否是局部变量无关，如局部静态对象的生命周期，直到程序运行结束才被销毁

局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使所在的函数结束执行也不会对它有影响。如果局部静态变量没有显示的初始值，它将执行值初始化，内置类型的局部静态变量被初始化为0

在所有函数体之外定义的对象存在于程序的整个执行过程中，此类对象在程序启动时被创建，直到程序结束才会销毁。

局部变量的生命周期依**赖于定义方式**。







### 自动对象p185




### 函数声明

函数只能定义一次，但可以声明多次
如果一个函数永远不会被我们用到，那么它可以只有声明而没有定义

函数的三要素（返回类型，函数名，形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。

函数声明也称作**函数原型**



### 分离式编译p186-187







## 参数传递

形参的初始化机理与变量初始化一样

引用传递，传引用调用
值传递，传值调用


### 传值参数

指针形参

熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。

在C++语言中，建议使用引用类型的形参替代指针



### 传引用参数

1. 使用引用避免拷贝：拷贝大的类类型对象或这容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作，函数只能通过引用形参访问该类型的对象
2. 如果函数无需改变引用形参的值，最好将其声明为**常量引用**
3. **使用引用形参返回额外信息**：一个函数一般只能返回一个值，然而有时函数需要同时返回多个值，引用形参可以一次返回多个结果



### const形参和实参

当形参是const时，必须要注意前面关于顶层const的讨论。


当用实参初始化形参时，形参的顶层const被忽略掉了 

当形参有顶层const时，传给它常量对象，或者非常量对象都是可以的；所以在定义函数时，这两种情况不构成重载（如果是const引用（**引用的const是底层const**）或指向常量的指针则可以构成重载）。



**指针或引用形参与const**

可以使用非常量初始化一个底层const对象，但是反过来不行；也就是说不能用底层const初始化非常量对象

同时一个普通的引用必须用同类型的对象初始化。




#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。
此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。如不能把const对象，字面值或者需要类型转换的对象传递给普通的引用形参
这种错误绝不像看起来那么简单，他可能造成出人意料的后果。





### 数组形参（实际上是指向首元素的指针）

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：**不允许拷贝数组以及使用数组时（通常）会将其转换成指针**。因为不能拷贝数组，所以我们**无法以值传递**的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。


尽管不能以值传递的方式传递数组，但是我们**可以把形参写成类似数组的形式**：

```cpp
	//尽管形式不同，但这三个print函数是等价的
	//每个函数都有一个const int*类型的形参
	void print(const int*);
	void print(const int[]);	//可以看出，函数的意图是作用于一个数组
	void print(const int[10]);	//这里的维度表示我们期望数组含有多少元素，实际不一定
```

当编译器处理对print函数的调用时，只检查输入的参数是否是const int *  类型



```cpp
    int i = 0,j[2]={0,1};  
    print(&i);      //正确：&i的类型是int *
	print(j);       //正确：j转换成int*并指向了j[0]
```

如果我们传给print函数的是一个数组，则实参自动地转换成指向数组首元素的指针，**数组的大小对函数的调用没有影响**



和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界





**数组尺寸问题**

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技巧

- 使用标记指定数组

  典型示例是C风格字符串，末尾有空字

  但对于像int这样所有取值都是合法值的数据就不太有效了

- 使用标准库（这种情况下，**排序算法怎么编写**）

  传递指向数组首元素和尾后元素的指针（begin，end函数，在iterator头文件中）

- 显示传递一个表示数组大小的形参



当函数不需要对数组元素执行写操作时候，数组形参应该是指向const的指针。只有当函数确实要改变元素之的时候，才把形参定义成指向非常量的指针。







### 数组引用做形参

C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定对应的实参上，也就是绑定到数组上

**数组的大小是构成数组类型的一部分，对于引用，数组的大小就不会被忽略了**。

```cpp
    void print(int (&arr)[10]){//两端括号必不可少
        for(auto elem : arr)
           cout << elem << endl
	}
```

​    

因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也**限制了**print函数的可用性，我们只能将函数作用于大小为10的数组



```cpp
    int i = 0, j[2] = {0,1};
    int k[10] = {0,1,2,3,4,5,6,7,8,9}、
    print(&i);  //错误：实参不是含有10个整数的数组
    print(j);   //错误：实参不是含有10个整数的数组
    print(k);   //正确：实参是含有10个整数的数组
```

p578介绍可以给引用类型的形参传递任意大小的数组的方法



#### 传递多维数组

当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个**指向数组的指针**。数组的第二维（以及后面所有的维度）的大小都是数组类型的一部分，**不能省略**

```cpp
    //matrix指向数组的首元素，该数组的元素是由10个整数构成的数组，两端括号必不可少
    void print(int (*matrix)[10], int rowSize){ /*...*/}
```

也可以使用数组的语法定义函数，此时编译器会一如既往地**忽略掉第一个维度**，所以最好不要把它包括在形参列表内

```cpp
    //等价定义
    void print(int matrix[][10],int rowSize){ /*...*/}
```





### main:处理命令行选项







### **不要返回局部对象的引用或指针**

即使看起来返回的是常量，但返回时会转换成一个临时对象

要想确保返回值安全，不妨提问：引用所引的是在函数之前已经存在的哪个对象？

返回局部对象的引用是错误的，返回局部对象的指针也是错误的。

一旦函数完成，局部对象被释放，指针将指向一个不存在的对象









### 主函数main的返回值

p203略























## 函数重载

如果**同一作用域内**的几个函数名字相同但形参列表不同，我们称之为重载函数（overloaded）

函数的名字**仅仅是**让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担



### 定义重载函数

对于重载函数，它们应该在**形参数量上**或**形参类型上**或**不同类型形参的位置**有所不同。



### 判断两个形参的类型是否相异

1. 省略形参名时候
2. 使用类型别名时





### 重载和const形参

一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

```cpp
Record lookup(Phone);
Record lookup(const Phone);	//重复声明了Record lookup(Phone)

Record lookup(Phone*);
Record lookup(Phone* const);	//重复声明了Record lookup(Phone *)
```

如果形参是某种类型的**指针或引用**，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是**底层的**

```cpp
//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
//定义了4个独立的重载函数

Record lookup(Account&);		//函数作用于Account的引用
Record lookup(const Account&);	//新函数，作用于常量引用

Record lookup(Account*);		//新函数
Record lookup(const Account*);	//新函数，作用于指向常量的指针
```

上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数。

1. 因为const不能转换成其他类型，所以我们只能把const对象（或指向const的指针）传递给const形参。
2. 相反的，因为非常量可以转换成const，所以上面的四个函数都能作用于非常量对象或者指向非常量对象的指针。
3. 不过当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会**优先**选用非常量版本的函数。





### const_cast和重载

const_cast在重载函数的情景中最有用。

如

```cpp
const string &shorterString(const string &s1, const string &s2){
	return s1.size() = s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string的引用。

我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用。

因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

```cpp
string &shorterString(string &s1, string &s2){
	auto &r = shorterString(const_cast<const string&>(s1), 
                            const_cast<const string&>(s2));
	return const_cast<string&>(r);
}
```

在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。

const版本返回对const string的引用，这个引用**事实上**绑定在了某个初始的非常量实参上。

因此，我们可以再将其转换回一个普通的string&，这显然是安全的。



上述例子，似乎可以直接重载达到同样的效果（但如果第一个函数中的逻辑代码特别多，此时第二个函数的作用就会显得非常明显）







### 重载与作用域

p210









## 默认实参

- 某些函数有这样一种形参，在函数的很多次调用中，它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参。
- **调用**含有默认实参的函数**时**，可以包含该实参，也可以省略该实参
- 默认实参**作为形参的初始值**出现在形参列表中，我们可以为一个或多个形参定义默认值。
- 不过需要注意的是，一旦某个形参被赋予了默认值，它**后面的所有**形参都**必须**有默认值。



#### 使用默认实参调用函数

- 如果想使用默认实参，只要在调用函数的时候省略该实参就可以了（而且只能省略尾部实参）

- 函数调用时，实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）

- 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序：

  尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的的形参出现在后面



#### 默认实参声明

- 通常，应该在函数声明中指定默认实参，并将该声明放在合适的**头文件**中，并且一个函数只声明一次

- 多次声明同一个函数也是合法的。但在给定的作用域中一个形参只能被赋予一次默认实参，

  换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值



#### 默认实参初始值

局部变量**不能作为**默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。

> 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：

```cpp
//wd、def和ht的声明必须出现在函数之外
typedef string::size_type sz;
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen();	//调用 screen(ht(), 80, ' ')


//用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：
void f(){
    def = '*';		//改变默认实参的值
    sz wd = 100;	//隐藏了外层定义的wd，但是没有改变默认值
    window = screen();	//调用screen (ht(), 80, '*')
}
```

我们在函数f2内部改变了def的值，所以对screen的调用将会传递给这个更新过的值。

另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的wd，但是该局部变量与传递给screen的默认实参**没有任何关系**









## 函数匹配

#### 调用重载函数

- 编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数
- 当调用重载函数时，有三种可能的结果：
  - 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码
  - 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息
  - 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用**



#### 确定候选函数和可行函数

- 函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为**候选函数**
  - 候选函数具备**两个特征**：
    - 一是与被调用的函数同名
    - 二是其声明在调用点可见
- 第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数**
  - 可行函数也有两个特征：
    - 一是其形参数量与本次调用提供的实参数量相等
    - 二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型
    - Note：如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量

- 在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否匹配

- 和一般的函数调用类似，实参与形参匹配的含义可能是：它们具有相同的类型，也可能是实参类型和形参类型满足转换规则

  



#### 寻找最佳匹配（如果有的话）

函数匹配的第三步是从可行函数中选择与本次调用**最匹配**的函数

最匹配的基本思想是：**实参类型与形参类型越接近**，它们匹配得越好

编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。

在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数

如果有且只有一个函数满足下列条件，则匹配成功：

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
- 至少有一个实参的匹配优于其他可行函数提供的匹配

如果在检查了所有实参之后，没有任何一个函数脱颖而出，则该函数调用是错误的。编译器将报告二义性调用的信息。

调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理



#### 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，**具体排序**如下：

1. 精确匹配，包括以下情况：
   1. 实参类型和形参类型相同
   2. 实参从数组类型或函数类型转换成对应的指针类型
   3. 向实参添加顶层const或者从实参中删除顶层const
2. 通过const转换实现的匹配
3. 通过类型**提升**实现的匹配
4. 通过算术类型转换或指针转换实现的匹配
5. 通过类型转换实现的匹配



#### 需要类型提升和算数类型转换的匹配

内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但幸运的是，在设计良好的系统中函数很少会含有与下面例子类似的形参

所有算数类型转换的级别都一样，如：从int向unsigned int的转换并不比从int 向double的转换级别高。再如下例：

```cpp
void manip(long);
void manip(float);

manip(3.14);	//错误：二义性调用
//字面值3.14的类型是double，它既能转换成long，也能转换成float。因为存在两种可能的算数类型转换，所以该调用具有二义性
```



#### 函数匹配和const实参

如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时，编译器通过实参是否是常量来决定选择哪个函数：

```cpp
Record lookup(Account&);			//函数参数是Account的引用
Record lookup(const Account&);		//函数的参数是一个常量引用
const Account a;
Account b;
lookup(a);						 	//调用lookup(const Account&)
lookup(b);							//调用lookup(Account&)
```

对于第二个调用，两个函数都是可行的，因为就可以使用b初始化常量引用，也可以用它初始化非常量引用。

然而，用非常量对象初始化常量引用**需要类型**转换，接受非常量形参的版本则与b精确匹配。因此，应该选用非常量版本的函数。

指针类型的形参也类似。如果两个函数的唯一区别是它的指针形参指向常量或非常量，则编译器能通过实参是否是常量决定选用哪个函数：如果实参是指向常量的指针，调用形参是const*的函数；如果实参是指向非常量的指针，调用形参是普通指针的函数。









#### 函数指针小结

- 函数的类型由它的**返回值**和**形参类型**共同决定，与函数名无关
- 要想声明一个指向函数的指针，只需要用该指针替换函数名即可
- 当我们把函数名作为赋值号右侧的值使用时，该函数自动地转换成指针
- 可以直接使用指向函数的指针调用该函数，无需提前解引用指针
- 在指向不同函数类型的指针间**不存在**转换规则
- 如果定义了指向重载函数的指针，编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个**精确匹配**
- 虽然不能返回一个函数，但是能返回指向函数类型的指针
- 虽然不能定义函数类型的形参，但是形参可以是指向函数的指针
  - 此时形参看起来是函数类型，实际上却**转换成**指针使用：
- 可以使用**尾置返回类型**的方式声明一个返回函数指针的函数`auto f1(int) -> int (*)(int, int);`
- decltype作用于某个函数时，它返回函数类型**而非**指针类型

