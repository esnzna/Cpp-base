# 构造函数

- 定义一个类时，可**显式或隐式**的指定在此类型对象上`拷贝`、`移动`、`赋值`、`销毁`时做什么。通过5种`成员函数`实现`拷贝控制`操作：
  - `拷贝构造函数`：用同类型的另一个对象**初始化**本对象时做什么（拷贝初始化）
  - `拷贝赋值算符`：将同类型的另一个对象**赋值**给本对象时做什么（拷贝赋值）
  - `移动构造函数`：用同类型的另一个对象**初始化**本对象时做什么（移动初始化）
  - `移动赋值算符`：将同类型的另一个对象**赋值**给本对象时做什么（移动赋值）
  - `析构函数`：本对象销毁时做什么（析构）
  - ```cc
    class A{
    public:
        A(); //
        A(const A&);
        A& operator=(const A&);
        A(A&& );
        A& operator=(A&& );
    }
    ```
  
    
- 如果类未定义这些拷贝控制成员，编译器会**自动合成**一部分缺失的操作，因此很多类不需要自定义拷贝控制。**最困难的经常是认识到什么时候需要自定义拷贝控制：编译器合成版本的行为可能并非预期。**



- `构造函数`：控制类对象的初始化过程，只要类的对象被创建，就会执行构造函数。
- `构造函数不能是const成员函数`，因为构造时要改变类。
  - **`即使是const对象，也是构造函数完成初始化过程后才成为常量，初始化过程中可以向其写值`**
  - 构造函数和析构函数上**不允许**使用const





## 构造函数初值列表

> 负责初始化新创建的对象的一些成员。形式是成员名字的列表用逗号隔开，每个名字后紧跟括号（或花括号）括起来的初值

- 在构造函数初值列表中显式初始化成员相当于`初始化`，在构造函数体内赋值相当于`赋值`
- 被构造函数初值列表**忽略**的成员，会执行类似合成默认构造函数的隐式初始化。（即初始化为`类内初始值`，或`默认初始化`）
- 如果成员是`引用`、`const成员`等不可被赋值的类型，或是某种`不可被默认初始化`的类型（未提供默认构造函数），则它们**只能**放在构造函数初值列表中初始化，或提供类内初始值
- 每个**内置类型成员**都应被构造函数初值列表或类内初始值初始化，否则默认初始化为未定义

- 成员`初始化`流程（`优先级：构造函数初值列表>类内初始值>默认初始化`），（构造函数体内赋值的阶段`不属于`初始化阶段）：

  1. 如果成员在构造函数初值列表中，则初始化为`构造函数初值列表`提供的值
  2. 如果成员不在构造函数初值列表中但有类内初始值，则初始化为`类内初始值`
  3. 如果成员既不在构造函数初值列表中又没有类内初始值，则`默认初始化`

- 构造函数初值列表只说明用于初始化的值，并未规定`求值顺序`

  - 成员的初始化顺序只与成员在类定义中出现的`声明顺序`一致，与在构造函数初值列表中的顺序无关

  - `最佳实践`：
    - 类的成员都放在构造函数初值列表中初始化，或提供类内初始值
    - 最好令构造函数初值列表的顺序与成员声明顺序一致
    - **尽量避免**用构造函数初值列表中的一个名字初始化其中的另一个名字

- 构造函数中也可用`默认实参`。若一个构造函数为所有形参提供了默认实参，它实际上定义了`默认构造函数`





## 默认构造函数

- 如果类没有显式定义构造函数，编译器会隐式定义默认构造函数，被称为`合成的默认构造函数`
- 如果定义了其他的构造函数，但没有显示定义默认构造函数，则默认构造函数被认为是**删除的**（VS中提示是这样写得）
- 合成的默认构造函数对成员初始化：

  - 如果成员存在**类内初始值**，则用该值初始化
    - `类内初始值`：**C++11**允许成员在类中声明时同时提供一个初始值，该初始值会在构造时被构造函数使用。
    - (注意：非常量的static成员**不能**有类内初始值)
  - 如果成员没有**类内初始值**，则用**默认初始化**，值是**随机**的（**这本书里是啥意**）
- 可用`constructor()=default;`手动定义一个构造函数由编译器合成。它可用于类内和类外的定义。



### 默认构造函数的作用

- 当对象被默认初始化时执行默认构造函数。`默认初始化`发生的情形：

  - 块定义域内不使用初始值就定义一个非静态变量/数组
  - 类本身含有类类型成员并使用合成的默认构造函数
  - 类类型成员没有在构造函数初值列表中显式初始化

- `值初始化`发生的情形（数值型初始化为0的那种）：
  - 数组初始化时提供的初始值小于数组大小
  - 不使用初始值定义一个**局部**静态变量
- 书写`T()`的表达式进行显式值初始化，例如vector仅指定元素数量时

- 使用默认构造函数时，不可用括号

- 例子：使用默认构造函数

```cpp
Sales_data obj();   //错，编译器认为这是函数声明
Sales_data obj;     //对，默认初始化，调用默认构造函数
```

### 某些类不能依赖于合成的默认构造函数

- 只有类没有声明任何构造函数时才会合成构造函数。
- 合成的默认构造函数**可能产生未定义**，如块中的**内置类型**或**复合类型（引用/指针）**未提供类内初始值时，它们被默认初始化的值**未定义**
  - 含有内置类型或复合类型成员的类**应该**在类的内部初始化这些成员，或者定义一个自己的默认构造函数

  - 否则，用户在创建对象的时候，就可能得到未定义的值**（可能是很奇怪的值）**
- **编译器不能为某些类合成默认构造函数，如类内的某成员不存在默认构造函数，因而不能被默认初始化时**
  - 例：如果类A没有默认构造函数，类B有个类A类型的成员，则类B**不能**定义默认构造函数，因为无法默认初始化类A类型的成员，此时Ｂ必须提供其他构造函数并在初值列表中对成员A进行初始化：**已验证**







## 拷贝构造函数和拷贝赋值算符

### 拷贝构造函数

- `拷贝构造函数`：这种构造函数的第一个参数是`自身类类型的引用`，且任何额外参数都有**默认值**。
  - 拷贝构造函数的第一个参数**必须**是引用类型（否则传参时需要拷贝，**循环调用**）。
  - 虽然也可定义为非const，但**几乎总是用**`const引用`（不会改变被拷贝对象，且const引用能接受更多类型的参数）。
  - 拷贝构造函数**经常会被隐式使用**（例如函数的传参和返回值），**故不应该**是`explicit`
  - 若未自定义拷贝构造函数，即使定义了其他构造函数，编译器**也会**合成一个拷贝构造函数（这一点与默认构造函数不同）

### 拷贝赋值算符

- **赋值算符**是名为`operator=`的函数
- 拷贝赋值算符接受一个与其所在类型相同的参数，**返回左侧运算对象的引用**（为与内置类型的赋值保持一致）
- （子类和父类之间的赋值操作，应该是子类可以赋值给父类，调用父类的拷贝赋值算符）




## 移动构造函数和移动赋值算符

### 移动构造函数

- 移动构造函数的第一个参数是该类类型的`右值引用`，且**任何额外参数都必须有默认实参**

- 移动构造函数必须确保移后源对象处于`析构安全`的状态，即销毁它对程序没有任何影响

  ```cc
  //移动构造函数
  StrVec::StrVec(StrVec &&s) noexcept :       //传入右值引用，且声明为noexcept表示不会抛出异常
                elements(s.elements),         //初值列表中拷贝指针，让该对象接管传入对象的资源
                first_free(s.first_free),
                cap(s.cap)
  {
      s.elements=s.first_free=s.cap=nullptr;  //将传入对象的指针置为nullptr，表示不再管理这些资源（即将传入对象置于析构安全状态）
  }
  ```

  



### 移动赋值算符

- `移动赋值算符`执行与析构函数和移动构造函数相同的操作

  - 与移动构造函数一样，如果移动赋值运算符不抛出任何异常，就应该将它标记为noexcept
  - 类似拷贝赋值运算符，移动赋值运算符必须正确处理**自赋值**

- 移动赋值算符处理`自赋值`的方法：判断this指针是否等于右侧对象的**地址**（即判断右侧是否是std::move产生的左侧对象的右值）

- 关键点：不能在使用右侧运算对象的资源之前，就释放左侧运算对象的资源（可能是相同的资源）

  ```cc
  //移动赋值算符
  StrVec &StrVec::StrVec(StrVec &&rhs) noexcept {         //输入是右值引用，且不会抛出异常
      if(this!=&rhs){                                     //检查this指针是否等于右侧对象的地址，即是否自赋值
          free();                                         //释放左侧对象管理的资源
          elements=rhs.elements;                          //拷贝指针，让左侧对象接管右侧对象的资源
          first_free=rhs.first_free;
          cap=rhs.cap;
          rhs.elements=rhs.first_free=rhs.cap=nullptr;    //将右侧对象置于可析构状态
      }
      return *this;
  }
  ```

- 从对象移动数据不会销毁此对象，但有时移动后会将原对象销毁（如函数返回值）。**必须保证移后源对象可析构**，实现方式是将其指针成员置为`nullptr`
- 移后源对象的值是未定义的，不应该对其值有任何假设（即程序中不应该依赖于移后源对象中的数据）
- **警告：**在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设

  一般来说，对象有效是指，可以安全地为其赋予新值或可安全使用而不依赖当前值







## 合成的操作

### 合成拷贝构造和拷贝赋值

- `合成的拷贝构造函数`：若非删除，则会将其参数的**非static成员**`逐个`拷贝到正在构造的对象中：

  - 内置类型：直接拷贝
  - 类类型：用使用该类的拷贝构造函数来拷贝（是哪个类的，成员的构造函数？）
  - 数组：逐元素拷贝（若元素是类类型，用元素的拷贝构造函数）
  - 用花括号列表初始化一个数组或一个聚合类的成员会调用拷贝构造（验证下）

- 例子：合成的拷贝构造函数

  ```cc
  class Sales_data{
  public:
      //拷贝构造函数，参数是该类类型的引用，经常是const引用
      Sales_data(const Sales_data &);
  private:
      string bookNo;
      int units_sold=0;
      double revenue=0.0;
  };
  //与合成的拷贝构造函数等价，逐个拷贝成员
  Sales_data::Sales_data(const Sales_data &orig):
                        bookNo(orig.bookNo),
                        units_sold(orig.units_sold),
                        revenue(orig.revenue)
                        {}
  
  ```

  

- `合成的拷贝赋值`：若未自定义拷贝赋值算符，编译器会合成一个

  - **和拷贝构造函数类似，对于某些类，合成的拷贝赋值运算符会禁止赋值操作(delete具体哪些情况参看 §13.1.6 p450)**

  - `合成的拷贝赋值算符`若非出于此目的，则会将右侧对象的每个非static成员赋予左侧对象的对应成员

- 例子：合成拷贝赋值算符

  ```cc
  class Sales_data{
  public:
      //拷贝赋值算符，参数是该类类型的引用，经常是const引用，返回该类类型的引用
      Sales_data &Sales_data::operator=(const Sales_data &);
  private:
      string bookNo;
      int units_sold=0;
      double revenue=0.0;
  };
  //左侧对象隐式绑定到返回的this，引用类型。右侧对象是传入参数，常量引用类型
  Sales_data &Sales_data::operator=(const Sales_data &rhs){
      bookNo=rhs.bookNo;
      units_sold=rhs.units_sold;
      revenue=rhs.revenue;
      return *this;
  }
  ```

  



### 合成的移动构造和移动赋值

- 若类自定义了拷贝构造函数、拷贝赋值算符或析构函数，则编译器**不会**合成移动构造函数和移动赋值算符
- 若一个类没有移动操作，类会使用**对应的**拷贝操作来代替移动操作（通过函数匹配）

- 编译器`合成移动构造函数和移动赋值算符`的情形：
  - 当一个类**未自定义任何拷贝控制成员**，**且**每个非static成员都可移动时。
  - 注意：内置类型成员都可移动，类类型成员若有移动操作也可移动

- **移动操作永远不会被`隐式`定义为删除函数：**但若显式要求生成`=default`的移动操作且编译器无法移动所有成员时，编译器会将移动操作定义为**删除的**
  - 若移动操作**可能**被定义为删除，编译器就不会合成它们
  - 将合成的移动操作定义为删除的情形（有一个重要例外）:
    - **移动构造函数**被定义为删除的条件：（注意下面前三个针对的是类成员）
      - **类成员**自定义了拷贝构造函数但未自定义移动构造函数
      - **类成员**未自定义拷贝构造函数且编译器不能合成移动构造函数
      - **类成员**的移动构造函数被定义为删除的或不可访问
      - 类的析构函数被定义为删除的或不可访问
    - **移动赋值算符**被定义为删除的条件：
      - **类成员**自定义了拷贝赋值算符但未自定义移动赋值算符
      - **类成员**未自定义拷贝赋值算符且编译器不能合成移动赋值算符
      - **类成员**的移动赋值算符被定义为删除的或不可访问
      - 类有成员是const的或是引用

### 移动与合成的拷贝控制相互作用

- 若类自定义了移动构造函数和/或移动赋值算符，则类的合成拷贝构造函数和合成拷贝赋值算符被定义为**删除**（因此**自定义了移动的类必须自定义拷贝**）

- 若类自定义了拷贝构造函数、拷贝赋值算符或析构函数，则编译器**不会**合成移动构造函数和移动赋值算符。

- 若类既有移动操作又有拷贝操作，则编译器使用**函数匹配规则**来判断调用哪个（赋值操作的情况类似）。`左值拷贝，右值移动`

  ```cc
  StrVec v1,v2;
  v1=v2;                      //右边是左值，拷贝
  StrVec getVec(istream &);   //返回值非引用，调用返回右值
  v2=getVec(cin);             //右边是右值，移动
  ```

- 当类有拷贝构造函数但没有移动构造函数，且使用右值构造时，`T &&到const T &的隐式转换`可保证拷贝构造函数被调用

  即`用拷贝代替移动`，赋值算符同理

- 用拷贝操作代替移动操作**几乎肯定是安全的**，一般拷贝操作满足对应移动操作的要求（但反之不可）

- 例子：用拷贝代替移动

  ```cc
  class Foo{
  public:
      Foo()=default;      //定义默认构造函数
      Foo(const Foo &);   //定义拷贝构造函数
      //未定义移动构造函数
  };
  Foo x;
  Foo y(x);               //左值，匹配到拷贝构造函数
  Foo z(std::move(x));    //右值，但无移动构造函数，Foo &&隐式转换为const Foo &，匹配到拷贝构造函数
  ```



### 拷贝并交换技术

- 用`swap实现赋值算符`时使用的`拷贝并交换`技术，这样得到的赋值算符既可当作移动赋值算符也可当作拷贝赋值算符（因为形参非引用，传参存在临时量，可根据实参类型决定拷贝/移动构造）
- 例子：“拷贝并交换技术”实现`拷贝赋值算符和移动赋值算符共享实现`

```cpp
class HasPtr{
    friend void swap(HasPtr &,HasPtr &);
public:
    //构造函数
    HasPtr(const string &s=string()):
          ps(new string(s)),i(0)
          {}
    //拷贝构造函数，行为像值
    HasPtr(const HasPtr &p):
          ps(new string(*p.ps)),i(p.i)
          {}
    //移动构造函数
    HasPtr(HasPtr &&p) noexcept :
          ps(p.ps),i(p.i)
          {p.ps=0;}
    //既可作为拷贝赋值算符，又可作为移动赋值算符
    //传参时生成临时对象，选择拷贝/移动构造函数：左值拷贝，右值移动
    //临时对象构造完成后，拷贝赋值和移动赋值都可用交换完成
    HasPtr &operator=(HasPtr rhs){
        swap(*this,rhs);
        return *this;
    }
    //析构函数
    ~HasPtr(){delete ps;}
private:
    string *ps;
    int i;
};
//使用共同实现的算符
HasPtr hp,hp2;
hp=hp2;             //右侧为左值，operator=作为拷贝赋值
hp=std::move(hp2);  //右侧为右值，operator=作为移动赋值
```

- 更新的`三/五法则`：所有5个拷贝控制成员应看作一个整体，一般定义了一个就应定义所有5个（定义移动的目的是避免额外开销，有拷贝需求的类一般也有移动需求）。
- 例子：为13.4的Message类定义移动操作







## 析构函数

- 析构函数执行与构造函数**相反**的操作：构造函数初始化对象的非static数据成员并执行函数体，析构函数执行函数体并销毁对象的非static数据成员
- `析构函数`的名字是波浪线`~`后接类名，它**没有返回值也不接受参数**，故**不可重载**，一个类只能有一个析构函数
- 构造函数和析构函数的共性和差异：

  - 构造函数有一个显式的初值列表和一个函数体；析构函数有一个函数体和一个隐式的析构部分。
  - 构造函数先做成员初始化再执行函数体，成员按照类中出现的顺序初始化；析构函数先执行函数体再销毁成员，成员按照初始化的**逆序**销毁。
- 析构函数的析构部分是**隐式的**，成员如何销毁完全取决于类型：
  - 类类型成员析构时调用析构函数，内置成员析构时什么都不做，特别是， 隐式销毁内置指针类型的成员**`不会delete`**它指向的对象
  - 与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，**智能指针成员在析构阶段会被自动销毁**

- 对象被销毁时调用析构函数：

  - 变量离开作用域被销毁
  - 类对象被销毁时成员被销毁
  - 标准库容器/数组被销毁时，元素被销毁
  - 动态对象的指针被delete时对象被销毁
  - 临时对象，创建它的完整表达式结束时被销毁
- 析构函数**自动运行**，故程序可按需分配资源，无需担心何时释放（前提是析构函数良好定义）
- 例子：析构函数自动运行

```cpp
{//进入新作用域
    Sales_data *p=new Sales_data;       //内置指针
    auto p2=make_shared<Sales_data>();  //智能指针
    Sales_data item(*p);                //拷贝构造对象
    vector<Sales_data> vec;
    vec.push_back(*p2);                 //拷贝进容器
    delete p;                           //管理动态对象的内置指针需手动delete
}
//离开作用域，p2、item、vec的析构函数自动运行
//销毁p2会递减其引用计数，计数为0时对象被释放
//销毁vec时其元素也被销毁
```

- Note：**当指向一个对象的引用或指针离开作用域时，析构函数不会执行**
- 若未自定义析构函数，编译器会合成一个
- `合成析构函数`若非删除，则其函数体为空，只有隐式的析构部分
- 析构函数体并不直接销毁成员，成员是在析构函数体执行之后的隐式析构阶段被销毁

**认识到析构函数体自身并不直接销毁成员是非常重要的**。成员函数是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的







## noexcept

- `noexcept`通知编译器，该函数不会抛出任何异常，出现在形参列表和初始化列表的冒号之间

  - 移动构造函数不需要分配新内存，只修改管理权限而不分配新资源，不会抛出异常
  - 除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。
  - 通知编译器不会抛出异常，可减少处理异常的开销（例如标准库容器处理元素时，为异常安全会优先用拷贝而不是移动）

- 使用noexcept时必须在函数**声明和定义**中**`都说明`**noexcept

- 不抛出异常的移动构造函数和移动赋值算符**都必须**标记为noexcept：

  1. 搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。

     1. 我们需要指出一个移动操作不抛出异常，这是因为两个相关联的事实：
        1. 首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的。
        2. 其次，标准库容器能对异常发生时其自身的行为提供保障。（如vector保证，如果调用push_back()时发生异常，vector自身不会发生改变。

  2. 拷贝构造可处理异常，移动构造不可处理异常（拷贝时先拷出再修改对象，抛出异常在修改对象之前。移动的过程就是修改原对象的过程，无法处理异常）

     因为移动一个对象通常会改变它的值。如果在的移动了部分而不是全部元素后抛出了一个异常，就会产生问题：旧空间中的移动源元素已经被改变，而新空间中未构造的元素可能尚不存在。

     如果拷贝过程中发生了异常，可以释放新分配的（还未成功构造的）内存并返回，并不会对原来的元素造成什么影响。

  3. 因此，对于移动构造函数可能抛出异常的元素，容器都会用拷贝而不是移动来处理它们（例如vector重新分配时使用拷贝而不是移动）

  4. 为了避免这种潜在的问题。除非容器知道元素类型的移动构造函数不会抛出异常，否则在重新分配的内存过程中，它就必须使用拷贝构造函数而不是移动构造函数。

     只有告诉容器：移动构造函数不会抛出异常，可安全使用，它才会移动。





## =default 和 =delete

### =default

- 将拷贝控制成员定义为`=default`可显式要求编译器生成合成的版本。只能对具有合成版本的成员函数使用（构造函数和拷贝控制成员）
- 当我们在类内用=default修饰成员声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样
- 例子：使用=default

```cpp
class Sales_data{
public:
    Sales_data()=default;
    Sales_data(const Sales_data &)=default;
    Sales_data &operator=(const Sales_data &);
    ~Sales_data()=default;
};
//=default可在类内定义也可在类外定义
Sales_data &Sales_data::operator=(const Sales_data &)=default;
```





### =delete

- 大多数类应该定义默认构造函数、拷贝构造函数、拷贝赋值算符，无论显式还是隐式

  但对某些类，这些操作没有合理的意义。例如：**iostream阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲**

- 若要阻止一个操作（例如禁止拷贝），正确做法是将其定义为**删除函数**

- `删除函数`是这样一种函数：虽然定义了，但**不可以**任何形式使用

```c++
NoCopy(const NoCopy&) = delete;		//阻止拷贝
NoCopy &operator=(const NoCopy&) = delete;		//阻止赋值
```

- 虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望**引导函数匹配过程**的时候，删除函数有时也是有用的。

- **不能删除析构函数**。若删除析构函数则无法销毁此类型对象。

  - 若析构函数是删除的，则：

    - 对于删除了析构函数的类，编译器**不允许**对该类型定义变量/临时对象

    - 若类的**类类型成员**删除了析构函数，则该类**也不能**定义变量/临时对象

    - 对于删除了析构函数的类，**可以分配该类型的`动态对象`**，但是**不能**释放这些对象

      - 例子：删除析构函数的类可分配动态对象

        ```cc
        struct NoDtor{
        public:
            NoDtor()=default;
            ~NoDtor()=delete;   //删除析构函数
        };
        NoDtor nd;              //错，不可创建变量
        NoDtor *p=new NoDtor(); //对，可分配动态对象但不可释放
        delete p;               //错，析构函数是删除的
        ```

- 对某些类的某些拷贝控制成员，编译器将合成的成员定义为删除函数。

  - 本质上，这些**规则的含义**是：若**类有数据成员**不可**默认构造**、**拷贝**、**赋值**、**销毁**，则该类对应的成员函数被定义为删除：

    - 删除合成析构函数：

      - 类**某成员**的析构函数是**删除的或不可访问**

    - 删除合成拷贝构造函数：

      - 类**某成员**的拷贝构造函数是**删除的或不可访问**
      - 类**某成员**的析构函数是**删除的或不可访问**（可能创建无法销毁的对象）

    - 删除合成拷贝赋值算符：

      - 类**某成员**的拷贝赋值算符是**删除的或不可访问**
      - 类有const成员或引用成员（将新值赋值给一个const对象是不可能的。但可给引用成员赋值，但改变的是底层共享对象而不是引用本身，不是期望结果。因此都被定义为删除的）

    - 删除默认构造函数：

      - 类**某成员**的析构函数是**删除的或不可访问**（可能创建无法销毁的对象）
      - 类有一个引用成员，但是它没有**类内初始化器**（p65）
      - 类有一个const成员，但没有类内初始化器且类型未显式定义默认构造函数

      p476, p553,p751介绍类的拷贝控制成员被定义为删除函数的其他原因。

- **C++11之前**，阻止拷贝控制的方法是将拷贝构造函数和拷贝赋值算符`声明为private且不定义`

  - 声明为private，保证类外拷贝时在**编译期**报错
  - 声明但不定义，保证友元和成员函数拷贝时在**链接期**报错
  - **声明但不定义一个成员函数是合法的，对此只有一个例外（p528）**。试图访问一个未定义的成员将导致链接时错误。

  - 希望阻止拷贝的**正经操作**是定义拷贝构造函数和拷贝赋值算符为=delete，**而不应该**将它们声明为private的。

- 最佳实践：

  - 不要在析构，复制和移动构造函数中干其他事，他们只应该处理所有权
  - 如果没有所有权问题，不需要写析构，复制和移动构造函数




### =delete和=default比较

- =delete**必须出现在第一次声明时**，而=default**只需在定义**时给出。因为编译器在函数声明时就必须知道它是否为删除的，以便禁止使用它
- =delete可对任意函数使用，而=default**只能**对编译器能合成的默认构造函数和拷贝构造成员使用





等号“=”是赋值还是构造取决于左值是否第一次出现。赋值是对已构造对象进行状态更新。赋值侧重于更新，拷贝侧重于构造。







## [三/五/零之法则](https://zh.cppreference.com/w/cpp/language/rule_of_three)

> - “三”是指[拷贝构造函数](https://www.zhihu.com/search?q=拷贝构造函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"576507360"})、拷贝[赋值运算符](https://www.zhihu.com/search?q=赋值运算符&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"576507360"})、[析构函数](https://www.zhihu.com/search?q=析构函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"576507360"})**这三者**之间关系，“五”是在**前面三个**的基础之上再**加上**移动构造函数、移动赋值运算符**这两个**
>
> - 这5个操作不必全部定义，可以只定义一两个。但这些操作经常是一个整体，需要同时定义。

### 三之法则

> 如果某个类需要用户定义的[析构函数](https://zh.cppreference.com/w/cpp/language/destructor)、用户定义的[复制构造函数](https://zh.cppreference.com/w/cpp/language/copy_constructor)或用户定义的[复制赋值运算符](https://zh.cppreference.com/w/cpp/language/copy_assignment)，那么它几乎肯定需要全部三者

### 五之法则

> 因为用户定义的析构函数、复制构造函数或复制赋值运算符的存在会阻止[移动构造函数](https://zh.cppreference.com/w/cpp/language/move_constructor)和[移动赋值运算符](https://zh.cppreference.com/w/cpp/language/move_assignment)的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数

### 零之法则

> 有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符的类应该专门处理所有权（这遵循[单一责任原则](https://en.wikipedia.org/wiki/Single_responsibility_principle)）。其他类都不应该拥有自定义的析构函数、复制/移动构造函数或复制/移动赋值运算符[[1\]](https://zh.cppreference.com/w/cpp/language/rule_of_three#cite_note-1)



### 具体的一些内容

1. 需要自定义析构函数的类也需要自定义拷贝和赋值操作
   - 在类的构造函数中new了一块动态内存并让类的某个指针成员指向它，在这个类析构时，默认析构函数就只会释放这个指针所占用的内存，而指针指向的内存空间它不管了！ 所以这种类需要自定义析构函数。
   - 浅拷贝：在进行类对象拷贝时，如果类对象含有指针成员，浅拷贝是仅仅拷贝了一个指针，让这个指针也指向原来已经存在的内存。因此，拷贝对象和被拷贝对象各自的指针成员共享同一块内存。
   - 深拷贝：深拷贝是生成一个新的指针，并为新的指针新开辟了一块内存，把原来那块内存上的内容拷贝，并让新的指针指向这块新内存
   - 在类在发生拷贝或者赋值时，如果执行默认拷贝构造函数和默认拷贝赋值运算符，只会进行简单的浅拷贝，会使得多个类对象的指针成员指向同一块内存。这样的话，当某个类对象结束了它的生命周期，会执行它自定义的析构函数，delete它的指针成员，于是这块内存便被释放了，那么此时其他的类对象的指针成员将成为空指针，或者多个类对象同时被销毁时，这块内存会被delete多次，这将会带来无法预料的后果
   - 基类的析构函数可以不遵循此法则，因为基类的虚构函数始终是虚函数，这种设置能够防止内存泄露
2. 需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然
   - 拷贝构造和操作符“=”是一起的，在定义的时候需要一起修改。
3. 一般来说，如果一个类定义了任何一个拷贝控制成员，它就应该定义所有五个拷贝控制成员
   - 类只有在定义了定义析构函数、拷贝构造函数、拷贝赋值运算符才能正常工作。
   - 类的实例通常会占用一些内存，拷贝类的成员需要进行读取数据、寻找内存、开辟空间、写入数据等操作，因此，拷贝会带来额外开销。
   - 而移动构造函数和移动赋值运算符能不开辟新内存完成对对象的移动，减少开销，所以定义它们能够减少性能上的开销。



注意：需要自定义拷贝和赋值时，**不一定**需要自定义析构函数。例如，为类的每个对象生成编号

（考虑一个类为每个对象分配一个独有的，唯一的序号。这个类需要一个拷贝构造函数为每个新创建的对象生成一个新的，独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是这个类不需要自定义析构函数）









## 委托构造函数

- `委托构造函数`：使用它所属类的其他构造函数执行初始化。即，将其职责委托给其他构造函数

  - 在委托构造函数的初值列表内**只允许有一个名字**，即类名，**不允许**有其他成员初始化表达式（即初始化列表只有一个构造函数的调用）
  - 委托构造函数的参数列表必须与另一个构造函数匹配，表示初始化时是在调用这个构造函数

- `执行顺序`：当一个构造函数委托给另一个构造函数时，受委托的构造函数的初值列表和函数体依次执行，然后才执行委托构造函数的函数体

- 例子：委托构造函数

  - ```cc
    class Sales_data{
    public:
        Sales_data(string s, unsigned cnt, double price):
                    bookNo(s), units_sold(cnt), revenue(cnt*price) {}
        Sales_data(): Sales_data("",0,0) {}                     //委托Sales_data(string s, unsigned cnt, double price)
        Sales_data(string s): Sales_data(s,0,0) {}              //委托Sales_data(string s, unsigned cnt, double price)
        Sales_data(istream &is): Sales_data() {read(is,*this);} //委托Sales_data()
    };
    ```









## explicit构造函数

- `转换构造函数`：如果构造函数只接受一个实参，则它实际上定义了由那种类型转换为该类类型的隐式转换

  - 即在需要该类型参数的地方，可能直接由实参隐式构造了对象

- 编译器只能执行**一步**隐式类型转换

  ```cc
  string null_book="9-999-99999-9";
  /* 上下文：item.combine()接受一个Sales_data类型，
   * 而Sales_data类有一个接受string的构造函数，但没有接受C风格字符串的构造函数
   */
  item.combine(null_book);        //对，需要一步转换：string->Sales_data，用string创建临时量Sales_data传入
  item.combine("9-999-99999-9");  //错，需要两步转换：字符串字面值->string->Sales_data
  ```


- 可将构造函数声明为`explicit`以禁止发生隐式类型转换，但仍可用`static_cast`做显式类型转换，此时会创建一个临时量

- explicit**只对**一个实参的构造函数有效。需要多个实参的构造函数**不能**用于执行隐式转换，所以**无须**将这些构造函数指定为explicit的

- 使用explicit的构造函数时，**只能**直接构造，不能拷贝构造（即，explicit的构造函数**不可用于拷贝构造**，此处的拷贝构造指的是使用=构造的情形）

- **只能在类内声明构造函数时使用explicit，类外定义时`不应重复`**

  ```cc
  class Sales_data{
  public:
      Sales_data()=default;
      Sales_data(const string &s, unsigned n, double p):
                  bookNo(s), units_sold(n), revenue(p*n) {}
      explicit Sales_data(const string &S): bookNo(s) {}
      explicit Sales_data(istream &);
  };
  explicit Sales_data(istream &is) {read(is,*this);} //错，定义时不应用explicit
  
  string null_book="9-999-99999-9";
  /* 上下文：item.combine()接受一个Sales_data类型 */
  item.combine(null_book)                     //错，string的构造函数是explixit，不可隐式转换
  item.combine(cin)                           //错，istream的构造函数是explixit，不可隐式转换
  Sales_data item1(null_book);                //对，直接初始化，显式调用构造函数
  Sales_data item2=null_book;                 //错，不可用隐式转换的拷贝初始化
  item.combine(Sales_data(null_book));        //对，显式构造
  item.combine(static_cast<Sales_data>(cin)); //对，显式转换，创建了临时的Sales_data对象
  
  
  
  //explicit的构造函数不可用于拷贝构造
  /*
  可以这么理解：首先用10去构造一个临时对象，然后将该临时对象拷贝构造v2，但由于vector的接受大小的构造函数是explicit的。
  所以无法用10去隐式构造一个临时对象。所以下面第二个语句是错误的
  */
  vector<int> v1(10);     //对，直接初始化
  vector<int> v2=10;      //错，vector的接受大小的构造函数是explicit
  
  void f(vector<int>);    //f的参数非引用，需拷贝初始化
  f(10);                  //错，int不可拷贝为vector
  f(vector<int>(10));     //对，从int直接构造临时vector
  ```

  

- 拷贝初始化时，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。

  - 但即使编译器跳过拷贝/移动构造函数，他们**仍必须是存在且可访问的**（例如不能是private）

  - 例子：跳过拷贝/移动构造函数，直接创建

    ```cc
    //编译器允许将上一行代码改写为下面一行，直接构造。
    string null_book="9-999-99999-9";   //拷贝初始化
    string null_book("9-999-99999-9");  //跳过拷贝构造函数，直接构造
    ```

  




- 接受单一参数`const char *`的string构造函数**不是**explicit
- 接受单一容量参数的vector构造函数是explicit