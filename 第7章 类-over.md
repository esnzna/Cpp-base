## 类

`成员函数`的**声明**必须在类的内部，但其定义可在类内或类外。



### this指针

> **任何**自定义名为this的变量都是**非法的**（哪怕在main函数中直接定义也不行）

- 成员函数通过名为`this指针`的`隐式形参`来访问调用它的对象
- **`this指针`是成员函数的`隐式形参`，调用时传入的实参是`对象的地址`**；可以将this指针**显示地**传入某个成员函数
- `this指针是一个指针常量（this指针本身是常量）`
- 默认`this指针指向的对象非常量`（成员函数没有被const修饰的情况下），因此**不能在const对象上调用普通成员函数**



### const成员函数

- `const成员函数`：在成员函数声明时，形参列表后加const关键字，使得该函数的隐式形参this指针成为`指向常量的指针`

- 常量对象、常量对象的指针/引用，都**只能**调用const成员函数

- 将成员函数设置为const有助于提高灵活性，使const对象和非const对象**都可**调用。

注意：`如果函数是const的，则其返回值不能是普通类型的引用，可以是const类型的引用`

```cpp
class Person{
public:
	Person(int a = 0) :  age(a){}
	int& getAge() const {		//错误,不能将const int绑定到int上
		return age;
	}
private:
	int age;
};
```







### 定义类相关的非成员函数

- 如果函数**概念上**属于类（即，是类接口的一部分）但不是类的成员，则它一般与类**`声明`**在**同一头文件中**
- IO类是不能被拷贝的类型，**只能用引用传参**。由于读写会改变流，使用时都**是普通引用，不是常量引用**
- **默认情况下**，拷贝类的对象其实是拷贝数据成员（浅拷贝）



### 类成员

- **类内初始值只能用`=`或`{}`的初始化形式，`不可以用 “()”`，因为会和成员函数声明混淆。**

- ```cc
  //因为我们无法避免这样的情况
  class Widget 
  {
  private: 
    typedef int x;
    int z(x);
  };
  //这样的话，就会变为函数声明。
  ```

  

- 可以但没必要在成员函数声明和定义处都说明inline，最好只在**类外定义**时才用

- `可变数据成员`：

  - 成员声明前加`mutable`关键字：这种成员**永远不会**是const，即使是在const对象内
  - **const成员函数可修改mutable数据成员**







### 返回*this的成员函数

- 通过区分成员函数是否是const的，**可对其重载**。原因是传入的隐式形参`*this`有`底层const`的差异
  - const对象上只能调用const成员函数，非const对象优先调用非const成员函数
  - 将返回`*this`的const成员函数重载为非const成员函数是**有必要的**，因为非const对象调用它时希望返回一个非const引用
  - 例子：重载出返回*this的const和非const的成员函数


```cpp
class Screen{
public:
    //非常量对象的版本
    Screen &display(ostream &os){               //传入this指针和返回引用都非const
        do_display(os); //非const方法调用const方法，传入do_display的this指针是指向const对象
        return *this;   //返回的this指针是非const方法的形参，故指向非const对象
    }
    //常量对象的版本
    const Screen &display(ostream &os) const{   //传入指向const的this指针，返回const引用
        do_display(os);
        return *this;
    }
private:
    //将底层实现的函数封装为private
    void do_display(ostream &os) const{         //不改变类内容也不返回类的引用，声明为const成员函数
        os<<contents;
    }
};
```

- 如上例这种在底层实现函数外套一层接口的方式**不会增加运行时开销**，因为定义于类内的成员函数都是内联的







### 类的前向声明和不完全类型

- 每个类定义了唯一的类型，两个类即使成员一样也是不同的类型

- `前向声明`：可以仅声明类而不定义它，只是向程序中引入名字并指明它是一种类类型
- `不完全类型`：**在声明之后，定义之前**，类是不完全类型
  - **不完全类型使用的场景**很狭窄，只用于`既不需要成员也不需要实体`的情形，如：
    - 可以定义**指向**不完全类型的**指针/引用**，
    - 可以声明（但不能定义）以不完全类型作为**形参/返回类型**的函数
    - **`类的静态成员可以是不完整类型`**
- 在创建类对象前，类必须有完整的定义，编译器才能知道它需要多少空间（可不用给出成员函数的定义，但是对象不能调用该函数）
- 一旦类名出现，就认为声明过了（**而非定义**），因此`类允许包含指向它自身类型的指针/引用`（此时类是不完全类型）
- 例子：类包含指向它自身类型的指针/引用

```cpp
class Link_screen{
    Screen window;
    Link_screen *next;
    Link_screen *prev;
};
```



### 类型别名

- 类可以自定义某种类型在其中的别名，这些**类型别名**和其他名字一样**受访问控制的约束**

- 用于定义类型的类型成员必须先定义后使用，这与普通成员不一样。因此`类型成员通常出现在类开始处`







### 类的作用域与名字查找

#### 类的作用域

- 在类外部定义成员函数时，**定义必须与类内的声明匹配**。如类内被声明为const成员函数，则定义时也需要const（static关键字**不要**在类外重复）
- 在类外部定义的成员，其名字必须包含类名的`作用域`。这时，其后的形参列表和函数体都会属于该类的命名空间，**但前面的返回类型不属于**

#### 名字查找

- 在名字所在的块中寻找声明，只考虑在**使用处之前**的声明
- 如果没找到，继续查找外层作用域（向前查找）
- 如果最终没找到声明，报错



- 编译器分`两步处理类`（因此成员函数体可随意使用类中的成员，无需在意它们出现的顺序）：

  - 编译成员的声明（包括成员函数的声明）
  - 直到类全部可见后才编译函数体

- **成员函数的·`函数体`·直到整个类可见后才会被处理，因此可使用类中定义的任何名字**

- 声明中使用的名字，包括**返回类型**/**形参列表**中使用的名字，都应该在使用前确保可见

- 内层作用域中**可重新定义**外层作用域中的名字

- 在类中，如果成员使用了外层作用域中定义的`类型`，则类**不能**在**之后**再定义该名字（下面的例子）

  - ```cc
    typedef double Money;
    class Account{
    public:
        Money balance(){return bal;}    //使用外层作用域定义的Money类型
    private:
        typedef double Money;           //错，类的成员使用了外面定义的类型，则不能在类内之后重新定义该类型
        Money bal;
    }
    ```


- 成员函数的函数体中使用的`名字查找`过程（哪怕在类外定义）：

  - 1. 在成员函数内部查找，只考虑使用前的声明
  - 2. 若成员函数内没找到，在类内继续查找，类的所有成员都被考虑（哪怕在该函数的声明的后面，因为函数的声明和类型声明是先于函数体编译）
  - 3. 若类内没找到，则在成员函数定义之前（只看该函数定义的位置，**与类定义的位置无关**）的作用域内查找
  - 4. 当成员函数定义在**类外部**时，名字查找第3步**不仅**要考虑类定义之前的全局作用域，**还要**考虑成员函数定义之前的全局作用域

- 不建议用其他成员的名字作为成员函数的形参，因为在函数体内会**屏蔽**外面的同名实体（包括类的成员）；这时可手动指定作用域


> 编译器是怎么实现类作用域的符号查找?
> 分为两步编译:
>
> 1. 首先值编译类的所有成员的声明(包括成员函数的声明而不是定义)，注意函数体是定义.
>    这样的话，在此步遍编译结束后，编译器会把所有的符号声明存储起来，供第二步使用.
> 2. 在编译成员的定义(如函数体),此时如果遇到一个变量就会首先从第一步中的存储查找
>
> ● 按照这种两阶段的方式处理类可以**简化类代码的组织方式**。 
>
> 因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。 
>
> 相反，如果函数的定义和成员的声明被同时处理，那么我们不得不在成员函数中使用那些早已出现的名字
>
> 
>
> ● 注意：这种两阶段的处理方式只适用于成员函数中的名字。 
>
> 声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。
>
> 如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。





## 构造函数

构造函数，见文件`构造函数`



## 友元

- 在类的内部声明某个函数为其友元时，要确保对该函数有访问权限
- `友元`：类可允许**其他类、其他类的成员函数，普通函数**访问它的非公有成员，方法是令其他类或函数成为它的友元
  - 可把另一个类的成员函数作为友元，只是要用类名指定作用域；
  - **友元类的成员函数**都可访问此类包括private成员在内的所有成员
  - 如果一个类要把一组重载函数声明为友元，则需对每一个函数**分别声明**才行
- 友元**不是**类的成员，也**不受**它所在的区域的访问控制级别的约束
- `友元关系没有传递性`，即A是B的友元，B是C的友元，这时A并不是C的友元

### 友元的声明

- 要把一个函数声明为类的友元，只需在类中加一条`friend`关键字开头的函数声明

- 友元声明**必须**在类的**内部**，但最好在类的开始或结束处集中声明

- 友元的声明**仅**指定访问权限，**不是通常意义的声明**。**`如果要使用，还需要在类外独立声明一次`**

  - 下列代码编译不通过：虽然在类外声明了friendfunc，但是friendfunc对于func还是不可见

  - 必须在func之前，这也说明了友元不是通常意义的声明），需要在类A之前声明friendfunc；

    - ```cc
      class BB {
      public:
      	friend void friendfunc(); //也可在此处定义该函数
      	void func() {
      		friendfunc();
      	}
      };
      void friendfunc();
      ```

  - 为使友元对类的用户可见，通常把**友元的独立声明**和类的声明放在同一头文件

- `类`和`非成员函数`的声明并不需要在友元声明之前。(下面两句话不好理解)

  - 当一个名字第一次出现在友元声明中时，隐式假定该名字在当前作用域中可见。
  - 但友元不一定真的要声明在当前作用域中。

- 但`类的成员函数`为某个类的友元时，该函数的声明必须在友元声明之前（为什么？）。即，如果类`A`的成员函数`f`是类`B`的友元，则声明顺序为：

  - 定义`A`类并在其中声明成员函数`f`，但此时不能定义。因为定义需要用到`B`的成员。
  - 定义`B`类并在其中声明`A::f`为友元
  - 定义`A::f`，这时它可使用`B`的成员

- 友元可被定义在类内部，这时是内联的（但它不是成员函数）

  - **即使友元函数在类的内部被定义了，它也必须在类外独立声明，这样才能可见**。
  - 换句话说，即使仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的（上例代码）


- **请注意，有的编译器并不强制执行上述关于友元的限定规则。**







## 聚合类

- `聚合类`：满足以下条件：
  - 所有成员都public
  - 没有定义构造函数
- 没有类内初始值
  - 没有基类和虚函数

- 可以提供花括号的初值列表用于`列表初始化`聚合类的数据成员，初始值的顺序必须和声明顺序一致

- 如果花括号初始化聚合类时参数较少，则靠后的成员被`值初始化`，类似数组

- 像这样显式列表初始化类的对象的成员的缺点：

  - 要求成员都public
  - 将正确初始化的任务交给用户
  - 修改成员时需要修改用户代码







## 字面值常量类

- 一般的字面值常量是算术类型、引用/指针，某些类也可以是字面值类型
- 字面值类型的类可能含有constexpr成员，这样的成员必须符合constexpr的所有要求，它是隐式的const成员
- 数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类但满足以下要求，也是字面值常量类：
  - 数据成员都是字面值类型
  - 至少有一个constexpr构造函数
  - 若数据成员有类内初始值，则内置类型成员的初值必须是常量表达式，类类型成员的初值必须用它自己的constexpr构造函数
  - 必须用析构函数的默认定义
- 虽然构造函数不能是const的，但字面值常量类的构造函数可以是constexpr的，且**必须**提供至少一个constexpr构造函数
- constexpr构造函数可声明为`=default`或`删除函数`。否则，constexpr构造函数必须既是构造函数（不能return）又是constexpr函数（唯一可执行的语句就是return）。因此`constexpr函数体一般是空的`，只使用初值列表
- constexpr构造函数必须初始化所有数据成员，初始值或者用常量表达式（内置类型），或者用constexpr构造函数（类类型）
- constexpr构造函数用于生成constexpr对象以及constexpr函数的参数/返回类型
- 例子：字面值常量类和constexpr构造函数

```cpp
//定义一个字面值常量类
class Debug{
public:
    constexpr Debug(bool b=true): hw(b), io(b), other(b) {}             //constexpr构造函数，仅使用初值列表
    constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) {}  //constexpr构造函数，仅使用初值列表
    constexpr bool any() {return hw||io||other;}
    void set_hw(bool b){hw=b;}
    void set_io(bool b){io=b;}
    void set_other(bool b){other=b;}
private:
    bool hw;    //硬件错误
    bool io;    //io错误
    bool other; //其他错误
};
constexpr Debug io_sub(false,true,false);   //字面值常量类的对象，调试io
if(io_sub.any())                            //等价于 if(true)
    cerr<<"print appropriate error messages"<<endl;
constexpr Debug prod(false);                //字面值常量类的对象，无调试
if(prod.any())                              //等价于 if(false)
    cerr<<"print an error message"<<endl;    
```









## 类的静态成员

- 形式是在成员声明前加`static`关键字
- 类的`静态成员`只与类本身相关，与其任何对象都无关。
  - 类的静态成员存在于任何对象之外，任何对象中都不包含与之相关的数据
  - 静态成员不与任何对象绑定，**故不存在`this指针`**。**因此既不能在函数体内使用this指针，也不能被声明为const成员函数。**

- 静态数据成员可以是public或private，类型可是常量、引用、指针、类类型等
- 可用类的`作用域运算符`直接访问静态成员，也可用类的对象、引用、指针来访问静态成员
- 例子：声明、定义、访问静态成员

```cpp
//声明静态成员
class Account{
public:
    void calculate() {amount+=amount*interestRate;}
    static double rate() {return interestRate;} //静态成员函数，它可在类内也可在类外定义
    static void rate(double);                   //静态成员函数
private:
    string owner;
    double amount;
    static double interestRate;                 //静态成员变量
    static double initRate();                   //静态成员函数
};
//定义静态成员 
void Account::rate(double newRate){         //定义静态成员函数，它可在类内也可在类外定义
    interestRate=newRate;
}
double Account::interestRate=initRate();    //定义静态成员变量，它只能在类外定义和初始化
//访问静态成员
double r;
r=Account::rate();  //通过作用域访问
Account ac1;
Account *ac2=&ac1;
r=ac1.rate();       //通过类引用访问
r=ac2->rate();      //通过类指针访问
```





### 静态成员注意

1. 静态数据成员

   1. `静态数据成员`并非在创建类的对象时被定义，因此**`静态数据成员不由构造函数初始化`。**

   2. 静态数据成员定义在任何函数之外，一旦被定义就存在于程序整个生命周期。

   3. 不能在类内部初始化**`非常量静态数据成员`**，`必须在类外定义和初始化`，一个静态数据成员只能被定义一次

      （ISO C++ forbids in-class initialization of non-const static member）

   4. > 可以这么想，我们所看到的类内数据成员都是声明，而不是定义；
      >
      > 普通的数据成员，在类创建对象的时候，被定义，分配内存空间；
      >
      > 而静态数据成员不属于任何对象，并非在创建类的对象的时被定义，静态数据成员不由构造函数初始化，即类创建对象的时候，自然无法给静态成员分配内存空间。所以，必须在类外进行定义，从而分配内存空间
      >
      > **初始化是赋一个初始值，而定义是分配内存。静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。**
      >
      > 
      >
      > **常量数据成员**，可以在类内赋予初值
      >
      > （如果仅限于于编译器可替换其值的情况，则一个初始化的const或constexpr static**不需要分别定义**；
      >
      > 如果将其值用于不能替换的场景，则该成员**必须有定义语句**。
      >
      > 如要把常量静态数据成员传给接受const int &的函数，则必须在类外定义）
      >
      > 总之，无论常量还是非常量静态数据成员，最好都要在类外定义
      >
      > **带有类内初始化表达式的静态 数据成员 必须具有不可变的常量整型类型，或必须被指定为“内联”**
      
   5. **对于常量静态数据成员，如果类内部提供了一个初值，则成员定义`不可`再提供初值。**

      **即使一个常量静态数据成员在类内被初始化了，通常也应在类外部定义一下（不提供初值）**

   6. 在某些非静态成员非法的场合，静态成员可正常使用，

      1. **静态成员可以是不完全类型**

      2. 特别的，静态数据成员的类型**可以是他所属的类类型**。而非静态数据成员只能被声明为它所属的类的指针或引用

      3. 可用静态成员做**默认实参**，非静态不可，因为它的值属于对象的一部分，读到声明时类未完全定义

   7. 为确保静态数据成员只被定义一次，最好将其定义与其他**非内联函数**的定义放在同一头文件

2. `静态成员函数`可在类内或类外定义，在类外定义时**`不可重复static`**关键字，`static只出现在声明中`。

   静态数据成员在类外定义时，也**不可重复static关键字**

   > static常用的两个作用，一个是作用域限制，一个是生存期限制。
   > 作用域限制：被static修饰的函数，**只能**用于代码本身文件的调用。
   > 生存期限制：对函数来说，这条是用来说类的静态成员函数的。在类对象出生前，类的静态成员函数就活着了。
   > 
   > 如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，
   >类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件。
   > 这样就导致无法在其他地方调用这个静态的类成员函数。如果要解决这个办法，就是在头文件中加extern。
   > 然而extern和static是一对对立的关键字，不能用在一起。
   > 
   > 所以在类外实现类成员函数时，函数名前加个static修饰符就报错了。



### 静态成员的类内初始化

- 例子：类内初始化的静态数据成员必须是字面值常量类型的constexpr

```cpp
class Account{
public:
    static double rate(){return interestRate;}
    static void rate(double);
private:
    static constexpr int period=30; //常量表达式
    double daily_tbl[period];       //可用于需要常量表达式的地方
};
```

- **必须在类外定义的情形**

```cpp
//如果要把Account::period传给接受const int &的函数，则必须在类外定义
//类内已提供初始值，则不可重复提供
constexpr int Account::period;

//如:有此函数（无论该函数是否是成员函数），如果传入参数是Account::period，且该实参没有在类外定义，则报错（g++会报错，VS不报错）
void show(const int &per);

```



### 静态成员能用于某些场景，而普通成员不能。

- 例子：静态数据成员的类型可以是他所属的类类型

```cpp
class Bar{
    static Bar mem1;    //对，静态成员可以是不完全类型
    Bar *mem2;          //对，指针可以是不完全类型
    Bar mem3;           //错，数据成员必须是完全类型
};
```

- 例子：静态成员做默认实参

```cpp
class Screen{
public:
    Screen &clear(char=bkground); //用静态成员做默认实参
private:
    static const char bkground;
};
```

