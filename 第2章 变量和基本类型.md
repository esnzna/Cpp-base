- C++定义了一些`基本内置类型`（字符、整型、浮点等），也提供了`自定义数据类型`的机制，`标准库`还定义了一些复杂的数据类型。
- 数据类型决定了程序中`数据`和`操作`的意义。
- `类型`决定了数据所占的bit数以及如何解释这些bit的内容





## 基本内置类型

- 基本数据类型
  - `算术类型`
    - 整型
      - 一般整型（short, int, long...)
      - 字符
      - 布尔

    - 浮点
      - 单精度
      - 双精度
      - 扩展精度

  - `空类型`：不对应具体值。






### 算术类型

- `算术类型`分为两大类：`整型`（包括字符和布尔）和`浮点`。
- **C++标准**只规定类型尺寸的`最小尺寸`，允许编译器赋予更大尺寸（在CSAPP第二章有x86和x64的各类型尺寸）。最小尺寸如表2.1：

![](../img/2_1.png)

- `布尔`类型的取值是`true`或`false`。bool类型虽然信息上只有一个bit，但由于`现代计算机的最小寻址单元是byte`，故bool型在这些机器上占8个bit的空间。
- int至少和short一样大，long至少和int一样大，long long至少和long一样大
- 除去bool和扩展的字符类型外，其他整型和浮点型都可分为`signed`和`unsigned`两种
- `char`的大小和机器字节一样
  - 除char外的其他字符类型用于扩展字符集，`wchar_t`用于确保可存放机器最大扩展字符集中的任意字符，`char16_t`和`char32_t`为Unicode字符集服务。
  - **未规定**默认的char是signed还是unsigned，**但其他整型默认是signed**
  - 未规定signed如何表示，但说明正负数量应该平衡。例如8bit的signed char在现代计算机上一般表示[-128,127]

- 选择数值类型的`最佳实践`	：

  - 数值不可能为负时用unsigned
  - 整型运算一般用int，超过int用long long
  - 算术表达式中不要用char或bool，**用char应明确指出signed或unsigned**
  - **浮点运算用double**，因为float精度不够，且float和double计算代价相差不大，而long double计算代价较大
- 可寻址的最小内存块称为`字节byte`，存储的基本单元称为`字word`。
  - 大多数机器的字节由8bit构成，而字由4字节（32bit）或8字节（64bit）构成。






### 类型转换

- `自动类型转换`：我们使用一种类型而对象实际上应取另一种类型时发生，**类型能表示的值的范围决定了转换的过程：**
  - 非bool 转 bool：初始值为0则转为false，初始值为其他值则转为true
  - bool 转 非bool：初始值为false则转为0，初始值为true则转为1
  - 浮点转整型：仅保留小数点之前的部分
  - 整型转浮点：小数部分是0，若整型数超过浮点容量，**有精度损失**
  - **给unsigned赋超出范围的值**：初始值对该unsigned类型最大值取模
  - **给signed赋超出范围的值**：**未定义**（在CSAPP第二章有讲运算的上溢和下溢）
  
- **算术表达式中同时有signed和unsigned，会将`signed自动转为unsigned`**





### 字面值常量

- 字面值常量的`类型` 由 `形式`和`值`决定

- `进制`：以0开头的整数是八进制，0x或0X开头的是十六进制

- 默认十进制字面值是signed，八进制和十六进制字面值**可能是**signed或unsigned

  - 十进制字面值的类型是int、long、long long中的**最小者**

  - 八进制和十六进制字面值的类型是int、long、long long、unsigned int、unsigned long、unsigned long long中的**最小者**。

    **因此`short`没有对应的字面值。**

- `浮点型字面值`表现为小数或以科学计数法表示的指数，**默认浮点字面值是`double类型`**

- 由单引号括起来的一个字符是`char型字面值`，由双引号括起来的零个或多个字符是`字符串型字面值`

- 字符串型字面值的类型实际是`常量字符`构成的`数组`。编译器在字符串结尾处添加空字符`'0'`，**因此字符串的长度比内容多1**

- `字符串分段书写`：如果两个字符串字面值位置紧邻，且**仅**由**空格、缩进、换行符**分隔，则实际上是一个整体。

- `转义序列`：在C++中有特殊含义的字符（如单双引号、问号、反斜线等）出现在字符串中时要转义，另外一些特殊字符（如缩进、换行等）也以转义序列书写

- `泛化的转义序列`：形式是`\x`后紧跟1个或多个十六进制数，或`\`后紧跟1、2、3个八进制数，其中数字部分表示的是字符对应的数值。如果超过3个，八进制只看前3个，十六进制看所有数字

- 超过8bit的十六进制字符是与表2.2中某个前缀作为开头的扩展字符集一起使用

- 表2.2中的**前缀**用于指定字符集，**后缀**用于指定字面值类型

![](../img/2_2.png)



- 例子：字面值常量

```c++
L'a'     //宽字符型字面值，类型是wchar_t
u8"hi!"  //utf-8字符串字面值（utf-8用8bit编码一个unicode字符）
42ULL    //无符号整型字面值，类型是unsigned long long
1E-3F    //单精度浮点字面值，类型是float
3.14159L //扩展精度浮点字面值，类型是long double
```

- bool类型字面值是`true`和`false`
- 指针字面值是`nullptr`（亦可用`NULL`或`0`）









## 变量

- 对cpp程序员来说，`变量`和`对象`一般可以互换使用
- `对象`：**一块能存储数据并具有某种类型的内存空间**





### 变量定义

- `定义`的基本形式：`类型说明符`后紧跟一个或多个`变量名`组成的列表，变量名由逗号分隔。（这是naive的理解，在`复合类型的声明`中有正经理解）
- `初始化`和`赋值`是完全不同的两个操作。
  - `初始化`是指创建对象时赋予初始值，`赋值`是指把对象的当前值擦除，用新值替代。
  - 同一条定义语句中，可用前面的变量，初始化后面的变量

- `列表初始化`：由花括号做初值。
  - 如果列表初始化的初始值存在丢失信息的风险，编译器会报错

- 例子：初始化变量

```c++
int a=0;
int a={0};
int a{0};
int a(0);
```

- `默认初始化`：定义变量时未指定初值，则是默认初始化，此时变量被赋予“默认值”。
  - **内置类型**的默认初始化由定义的位置决定：
    - 定义于任何函数外的变量被初始化为0（用g++测试了bool类型的值，初始化为0）
    - 定义于函数体内的内置类型`不被初始化`
    - （attention！所以`建议初始化每一个内置类型变量`）

  - **类类型对象**的默认初始化由类自己决定






## 变量声明和定义的关系

- `分离式编译`：将程序分割为若干个文件，每个文件可被独立编译
- C++将`声明`和`定义`区分开
  - `声明`使名字为程序所知，`定义`负责创建与名字相关联的实体。
  - `声明`规定了对象的类型和名字，这一点与定义相同。
  - 但除此之外，`定义`还申请存储空间，也可能赋予初值。
  - 变量能且只能被**定义一次**，但可以被**声明多次**。

- 任何包含显式初始化的声明都成为定义。
- `extern`：**若只想声明而不定义**，就使用关键字extern，且不要显式初始化。
  - **注意**：可以给extern显式初始化，一旦这样做，就成了定义。（编译器会给出警告）
  - 如果在**函数体**内初始化extern变量，就错误。
  - 注意：如果该变量在其他地方没有定义，则不能使用它，否则报错；

- `多个文件使用同一变量`：用extren将声明和定义分离，定义**必须出现且只能出现**在一个文件中，其他文件内应extern声明**但不可定义**。
- `静态类型语言`：在编译期检查类型





### 标识符

- `标识符`：由字母、数字、下划线组成，且必须以字母或下划线开头。长度没有限制，但大小写敏感。
- C++为标准库保留了命名。用户自定义标识符中：
  - 不能连续出现两个下划线
  - 不能以下划线紧接大写字母开头
  - 定义在函数体**外**的标识符不能以下划线开头
- 表2.3和2.4是C++保留的名字： 

![](../img/2_3.png)

![](../img/2_4.png)





### 名字的作用域

- `作用域`是程序的一部分，以花括号分隔
- 同一个名字在不同作用域中可能指向不同实体，名字的`有效区域`始于声明语句，结束于声明语句所在作用域的末端。
- `全局作用域`是定义在所有函数之外的名字的作用域，`块作用域`是花括号内部的作用域。
- 作用域可彼此包含，称为`外层作用域`和`内层作用域`。允许在内层作用域中**重新定义**外层作用域已有的名字。
- 用`域操作符::`手动指定作用域，左侧是作用域的名称，全局作用域的名称为空。







## 复合类型

关于符合类型见指针和引用单独那个文件





## 处理类型









### auto类型说明符

- `类型说明符auto`：让编译器通过初始值来推算变量的类型。因此auto类型的变量必须初始化。
- auto可以在一条语句中声明多个变量，但所有变量的初始基本数据类型都必须一样。
- 例子：auto声明多个变量

```c++
auto i=0, *p=&i;     //正确，i是整型，p是指向整型的指针
auto sz=0, pi=3.14;  //错误，sz是整型，pi是浮点
```

- 编译器推出的auto有时候和初始值不完全一样。
- `auto会忽略引用`：引用被用作auto的初始值时，真正参与初始化的是绑定对象的值，此时编译器用绑定对象的类型作为auto类型。
- `auto会忽略顶层const，保留底层const`。
- 例子：**auto会忽略引用，忽略顶层const，保留底层const**

```c++
int i=0, &r=i;
auto a=r;   //绑定int型的引用做初值，a是int型
const int ci=i, &cr=ci;
auto b=ci;  //ci是顶层const，忽略。b是int型
auto c=cr;  //cr是ci的引用，忽略。ci是顶层const，忽略。c是int型
auto d=&i;  //i是int，取地址得到指向int的指针。d是指向int的指针
auto e=&ci; //ci是const int，取地址得到指向const int的指针，是底层const不可忽略。e是指向const int的指针

```

- `使auto保留引用`：声名符中使用`&`
- `使auto保留顶层const`：在auto前加const 例子：auto保留引用和顶层const

```c++
/*接上例*/
const auto f=ci;  //手动指定f为顶层const。ci的类型是const int，经过const auto后得到f是const int。
auto &g=ci;       //手动指定g的类型为引用。引用的对象是ci，即g是const int。
auto &h=42;       //错，h是非常量引用。不能为非常量引用绑定字面值，只能绑定对象
const auto &j=42  //j是引用，绑定到const auto类型，即j是常量引用。可为常量引用绑定字面值
```





### decltype类型指示符

- `decltype`：返回操作数的类型。auto必须初始化，而decltype只需推导类型，不需初始化。
- `decltype保留引用和顶层const`，这一点和auto不同。因为decltype常用于查看类型，要返回原本类型，auto常用于定义变量，要考虑使用方便。
- 例子：decltype保留引用和顶层const

```c++
const int ci=0, &cj=ci;
decltype(ci) x=0; //x的类型是const int，顶层const被保留
decltype(cj) y=x; //y的类型是引用，引用对象是const int
decltype(cj) z;   //错，z是引用，必须初始化
```

- 如果decltype内表达式的内容可作为赋值语句的左值，则decltype得到引用类型。
- 如果decltype内表达式的内容是解引用操作，则decltype得到引用类型。（`解引用指针得到的是所指对象的引用`，而不是值）
- 如果decltype内表达式的内容是变量加上一层或多层括号，编译器把它当成一个表达式。变量是可作为左值的特殊表达式，故此时得到引用类型。
- 例子：对表达式求decltype

```c++
int i=42, *p=&i, &r=i;
decltype(r) a;    //错，r的推导结果是引用，必须初始化
decltype(r+0) b;  //对，r+0的结果是int，故b是未初始化的int
decltype(*p) c;   //错，解引用得到的结果是引用，c是绑定到int的引用，必须初始化
decltype((i)) d;  //错，d是绑定到int的引用，必须初始化
decltype(i) e;    //对，e是未初始化的int
```









### 编写自己的头文件

- 可在函数体内定义类，但一般不这么做
- 为确保各文件中类的定义一致，`类通常被定义于头文件中`，且类所在头文件的名字应与类名一样
- 头文件中通常包含那些只能被定义一次的实体，如类、const、constexpr等
- 头文件不能被多次包含，因为对象不能被多次定义
- 可用`预处理器`功能中的`头文件保护符`确保头文件被多次包含仍能安全工作。`预处理变量`有已定义和未定义两种状态。`#define`指令将一个名字定义为预处理变量，`#ifdef`判断一个预处理变量是否已定义，`#ifndef`判断一个预处理变量是否未定义。一旦结果为真，就执行后面的直到`#endif`。
- 例子：头文件保护符

```c++
//当此头文件第一次被包含时，定义预处理变量SALES_DATA_H，并执行该头文件中的“代码们”
//当此头文件再次被包含时，预处理变量SALES_DATA_H已定义，跳过该头文件中的“代码们”
#ifndef SALES_DATA_H
#define SALES_DATA_H
/*
 * 代码们
 */
#endif
```

- 预处理变量无视C++语言中关于作用域的规则，都是`全局可见`。所以整个程序中的每个预处理变量必须唯一。通常的做法是根据头文件的名字来命名保护符。另外，一般将预处理变量的名字全部大写。